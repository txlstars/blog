---
layout: post
title: 本地缓存学习笔记 
---

## Local Cache(本地缓存)

+ ### 用途：

    对于读多写少的数据，可以通过将数据缓存在本地内存中从而减少对远程服务的访问，
    降低对远程服务器的压力，同时提升性能(访问本地内存比网络调用快的多)

+ ### 缺点:
    对于有少量写的情况(通过设置失效时间解决)会在一段时间内存在不一致的情况

+ ### 阶段:

    + #### 启动阶段:

        1. Server启动后直接提供服务，由于刚开始缓存中没有数据因此请求大多会访问远程数据。启动阶段对后端服务压力会比较大,
           同时读写缓存，要求锁力度足够小

        2. 对于初始阶段没有数据的情况，我们可以在Server启动后先从远程批量拉取一些数据放在缓存中, 然后再提供服务。
           为了提高缓存命中率可以考虑筛选一些热点数据

    + #### 数据更新

        1. 过期更新:可以分类线上更新和线下更新。对于线上更新，每次访问缓存时判断是否过期，如果过期访问远程数据更新缓存再返回。

           对于线下更新，可以采取全量更新，或者记录每次没有命中的ID,线下离线更新。离线更新是和使用双buffer

        2. 通知更新:远程数据变动时通知服务更新本地缓存

    + #### 数据淘汰

        数据淘汰算法:LRU|LFU|FIFO|TinyLFU

+ ### 技术选型: 双buffer | 无锁Map | Map + list
    + 数据需要实时更新缓存: 无锁Map, 数据量大时选用 Map + List
    + 反之: 双buffer 

+ ### 指标:命中率|吞吐量(并发*(1/时延))

+ ### 实现
    多读多写情况的考虑
+ ### 成熟组件

    冷启动并发读写的问题(一读一写|多读一写|一读多写|多读多写)

冲突解决方式
+多阶hash表
+链式hash

读无锁

本地缓存组件:
[性能数据](http://www.bkjia.com/Javabc/1208329.html)
Caffeine
ConcurrentLinkedHashMap
LinkedHashMap_lru
Guava
EhCache2_lru
EhCache3_lru
infinispan_old_lru
infinispan_new_lru
[驱逐策略 & 过期策略](http://ifeve.com/design-of-a-modern-cache/)

next post: linux性能分析工具
