---
layout: post
title: 代码整洁之道学习笔记
---

## 优雅与效率的权衡

## 整洁代码
+ 勒布朗法则:稍后等于永不 Later equals never
+ 花时间保持代码整洁不但有关效率,还有关生存
+ 程序员遵从不了解混乱风险的经理的意愿,也是不专业的做法
+ 努力, 让世界比你来时更干净些
+ 你还得练, 孩子, 还得练
关键词:
    敏捷开发|极限编程|代码重构

## 有意义的命名(33-46)
+ 名副其实(名字代表含义)
    + 新换旧
    + 注释与名字的权衡(优先使用名字)
    + 上下文
    + 常数->枚举|剥离出类

+ 避免误导(避免歧义等)
    + accountList真的是List
    + 便面使用名字相似的命名
    + 避免 1 l 0 O 这种相近的符号

+ 做有意义的区分

+ 使用读得出来的名称
    + 避免无法读的缩写

+ 使用可搜索的名称
    + 数字
    + e这种单字母

+ 避免使用编码
    +匈牙利语标记法
    +成员前缀(高亮成员变量插件)
    +接口和实现(对实现进行编码)

+ 避免思维映射

## 函数(47-66)
+ 短小
    + 缩进小于2层
    + if while里面应该只有一行代码(下一个函数)

+ 只做一件事
    + 多个步骤是否在同一抽象层次上
    + 看能否再拆出一个函数
    + 向下规则

+ switch语句

+ 使用描述性的名称

+ 函数参数
    + 参数数量越少越好
    + 返回值不要通过参数输出 
    + bool参数可以分出两个函数
    + 二元函数转成一元
    + 三元函数
    + 参数->对象 降参
    + 参数列表
    + 动词与关键词(名字|参数)

+ 无副作用
    + 输出参数 调整为 类状态的改变
    + 函数中不应该有副作用,如果有副作用至少在函数名中给用户提示

+ 分隔指令与询问
    + 回答什么与做什么分开做
    + 避免使用输出参数

+ 使用异常替代返回错误码(分场景使用, 对于tars没必要使用异常)
    + 抽离try catch代码块
    + try catch/finally 分别处于函数的收尾
    + 全局枚举依赖

+ 别重复自己

+ 结构化编程
    + 顺序、分支、循环、函数
    + 具体的意思是：每个函数、函数中的每个代码块都应该有一个入口、一个出口。遵循这些规则，
    意味着在每个函数中只该有一个return语句，循环中不能有break或continue语句，而且永永远远不能有任何goto语句。

+ 面向对象编程
    + 封装、继承、多态

+ 如何写出这样的函数
    + 不断的分解函数|修改名称|消除重复|拆出类

+ 指明函数是否会抛异常
    + throw() nothrow
    + noexcept

## 注释(67-88)

+ 注释会随着时间变得无效乃至误导

+ 注释的利与弊
    + 如果编码足够有表达力, 注释根本不需要
    + 注释的恰当用法是弥补我们在用代码表达意图时遭遇的"失败"
    + 尽管有时候也需要注释, 我们也该多花心思尽量减少注释

+ 用代码来阐述
    + 变量名
    + 函数名
    + 类名

+ 好注释
    + 法律版权信息
    + 对意图的解释
    + 阐释
    + 警示
    + TODO注释要做还没有做的内容
    + 公共API中的Javadoc(API没有注释会导致使用的人浪费时间)

+ 坏注释
    + 太多了(每次当你想写注释的时候可以翻看文档查阅)

## 格式(89-104)

+ 代码风格对后来维护人的影响

+ 垂直格式
    + 200 - 500 行原则
    + 文件名 高层次概念 细节
    + 空行
    + 变量延迟声明(用到的时候再声明)
    + 主调在上|被调在下

+ 横向格式
    + 80列 120列
    + 空格
    + 缩进
    + 空范围 换行缩进加括号

+ 团队规则
    + 读者不希望同一个项目里面不同的文件代码风格不一样
    + 代码自动格式化工具(类比自动化测试工具)
    + vim gg == 10== v=

+ 鲍勃大叔的格式规则

## 对象和数据结构(90-112)
+ 数据抽象
    + 尽量避免存取函数, 会暴漏私有成员变量

+ 数据、对象的反对称性
    + 针对同一类型的对象或接口处理时的问题
    + 过程式代码难以添加新数据结构, 必须修改所有函数(分支,开闭原则)
    + 面向对象代码难以添加新函数, 必须修改所有类(多态,开闭原则)

+ 得墨忒耳律 类C的方法f只应该调用以下对象的方法
    + C
    + 由f创建的对象
    + 作为参数传给f的对象
    + 由C的实体变量所持有的对象
        
        final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();

+ 数据传送对象
    + 纯数据DTO
    + 数据+操作

## 错误处理(113-122)

+ 当错误发生时，程序员有责任确保代码照常工作
    + 错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法

+ 使用异常而非返回码
    + 关乎美感

+ 先写try-catch-finally

+ 使用不可控异常
    
+ 给出异常发生的环境说明
    + 打日志

+ 依调用者需要定义异常类
    + 打包类

+ 定义常规流程
    + 特例对象

+ 别返回null值
    + 抛异常或者返回特例对象

+ 别传递null值

## 边界(123-128)

+ 使用第三方代码
    + 适配器模式
    + 封装map
    + 对于第三方代码使用的部分要进行测试

+ 学习性测试
    + 测试脚本

+ 使用尚不存在的代码
    + 适配器模式封装本地API

## 单元测试(129-140)

+ 测试驱动开发

+ 自动化单元测试

+ TDD三定律
    + 在编写不能通过的单元测试前，不可编写生产代码
    + 只可编写刚好无法通过的单元测试，不能编译也算不通过
    + 只可编写刚好足以通过所有失败测试的生产代码

+ 保持测试整洁 
    + 测试代码和生产代码一样重要

+ 整洁测试
    + 可读性|简结且具有表达力
    + 构造测试数据|操作测试数据|检验操作结果
    + 一种测试语言

+ 每个测试一个断言
    + 单个测试中的断言数量应该最小化
    + 每个测试只测一个概念

+ First
    + 快速
    + 独立
    + 可重复
    + 自足验证
    + 及时

## 类(141-156)

+ 类的组织
    + 封装(放松封装就是下策)
    + 公有静态|私有静态|私有变量
    + 公有函数私有函数(紧随)
    + 自顶向下(看报纸)

+ 类应该短小
    + 如果无法为某个类命以精确的名称，这个类大概就长了，类名不超过25字符
    + 单一职责原则(类或模块应该只有一条嫁衣修改的理由)
    + 高内聚低耦合

+ 为了修改而组织
    + 开放-闭合原则
    + 依赖导致原则

## 系统(157-172)

+ 如何构造一个城市
    + 软件系统应将启动过程和启动过程之后的运行时逻辑分离开

+ 将系统的构造与使用分开
    + 构造过程搬迁到main或称之为main的模块中(not null)
    + 工厂(接口和实现分离)(隐藏构造细节)
    + 依赖注入 依赖查找 控制反转(引用传递代替实现new)
    + 反射机制

+ 扩容
    + 吞吐量|可用性|扩展性|一致性
    + 迭代 增量敏捷
    + 切分重构
    + TDD测试驱动开发:先编写测试|功能&测试|重构&测试

+ 测试驱动系统架构

+ 优化决策
    + 最好授权给最优资格的人
    + 延迟决策(越靠后获取的信息越多，更能精准的进行决策)

+ 使用添加了可论证价值的标准
    + 使用经过实战的组件

+ DSL领域特定语言

+ 无论是设计系统或单独的模块，简单最好

## 跌进(173-178)

+ 通过跌进设计达到整洁目的

1. 运行所有测试
    + 编写测试用例
    + SRP DIP 依赖注入 接口 抽象

+ 重构
    + 测试消除了对清理代码会破坏代码的恐惧
    + 系统模块化|切分关注面

2. 不可重复
    + 抽取公共代码|是否违反SRP
    + 针对类型不同可模版抽取重复代码

3. 表达力
    + 好的类名和函数名
    + 函数和类的尺寸短小
    + 标准命名法 如Command Visitor
    + 编写单元测试，测试用例可以起到文档的作用
    + 不断的尝试调整代码使代码更整洁

4. 整个系统中类和方法的数量应该尽量少
    + 测试|消除重复|表达力 > 类和方法数量少

## 并发编程(179-191)

+ 为什么要并发
    + 解耦目的和时机

+ 挑战

+ 并发防御原则
    + 单一职责原则
        + 分离并发相关代码和其他代码 
    + 限制数据作用域
        + 谨记数据封装
        + 严格限制对可能被共享的数据的访问
    + 使用数据复本
        + 多写 -> 单写(每个线程有自己的队列, 有一个线程搜集所有其他线程的队列)
        + 从多个线程手机所有副本的结果，并在单个线程中合并这些结果
    + 线程应尽可能地独立
        + 让每个线程在自己的世界中存在，不与其他线程共享数据

+ 了解Java库

+ 了解执行模型
    + 基础定义
        + 限定资源(数据库连接数、固定尺寸的读写缓存等)
        + 互斥
        + 线程饥饿(一个或一组线程很长时间内或永久被禁止，调度策略)
        + 死锁(线程1拥有A资源，线程2拥有B资源，现在线程A还需要获取B，线程2还需要获取A，两者谁也不愿意退让，处于死锁等待状态)
        + 活锁(任务或执行状态没有被阻塞，由于某些条件导致一直在重复尝试，失败，尝试，失败...)
            + 对比死锁的例子，线程1检测到B资源被占用后释放A资源，线程2检测到A资源被占用后释放B资源，紧接着线程1占用A，线程2占用B，接着循环)
    + 执行模型
        + 生产者-消费者模型
        + 读者-作者模型
        + 哲学家就餐模型

+ 警惕同步方法之间的依赖(锁方法力度太大一般不建议使用)

+ 保持同步区域微小

+ 很难编写正确的关闭代码
    + 编写永远运行的系统，与编写运行一段时间后瓶颈关闭的系统是两码事
    + 平静关闭很难做到，常见问题与死锁有关，线程一直等待永远不会来到的信号

+ 测试线程代码
    + 不要将系统错误归咎于偶发事件
    + 先使非线程代码可工作
    + 编写可插拔的线程代码

## 逐步改进(192-)

## JUnit内幕(251-)

## 重构SerialDate(267-)

## 味道与启发(285-)

## 其他
+ C++单元测试工具(googletest | googlemock)
