---
layout: post
title: 代码整洁之道学习笔记
---

## 优雅与效率的权衡

## 整洁代码
+ 勒布朗法则:稍后等于永不 Later equals never
+ 花时间保持代码整洁不但有关效率,还有关生存
+ 程序员遵从不了解混乱风险的经理的意愿,也是不专业的做法
+ 努力, 让世界比你来时更干净些
+ 你还得练, 孩子, 还得练
关键词:
    敏捷开发|极限编程|代码重构

## 有意义的命名(33-46)
+ 名副其实(名字代表含义)
    + 新换旧
    + 注释与名字的权衡(优先使用名字)
    + 上下文
    + 常数->枚举|剥离出类

+ 避免误导(避免歧义等)
    + accountList真的是List
    + 便面使用名字相似的命名
    + 避免 1 l 0 O 这种相近的符号

+ 做有意义的区分

+ 使用读得出来的名称
    + 避免无法读的缩写

+ 使用可搜索的名称
    + 数字
    + e这种单字母

+ 避免使用编码
    +匈牙利语标记法
    +成员前缀(高亮成员变量插件)
    +接口和实现(对实现进行编码)

+ 避免思维映射

## 函数(47-66)
+ 短小
    + 缩进小于2层
    + if while里面应该只有一行代码(下一个函数)

+ 只做一件事
    + 多个步骤是否在同一抽象层次上
    + 看能否再拆出一个函数
    + 向下规则

+ switch语句

+ 使用描述性的名称

+ 函数参数
    + 参数数量越少越好
    + 返回值不要通过参数输出 
    + bool参数可以分出两个函数
    + 二元函数转成一元
    + 三元函数
    + 参数->对象 降参
    + 参数列表
    + 动词与关键词(名字|参数)

+ 无副作用
    + 输出参数 调整为 类状态的改变
    + 函数中不应该有副作用,如果有副作用至少在函数名中给用户提示

+ 分隔指令与询问
    + 回答什么与做什么分开做
    + 避免使用输出参数

+ 使用异常替代返回错误码(分场景使用, 对于tars没必要使用异常)
    + 抽离try catch代码块
    + try catch/finally 分别处于函数的收尾
    + 全局枚举依赖

+ 别重复自己

+ 结构化编程
    + 顺序、分支、循环、函数
    + 具体的意思是：每个函数、函数中的每个代码块都应该有一个入口、一个出口。遵循这些规则，
    意味着在每个函数中只该有一个return语句，循环中不能有break或continue语句，而且永永远远不能有任何goto语句。

+ 面向对象编程
    + 封装、继承、多态

+ 如何写出这样的函数
    + 不断的分解函数|修改名称|消除重复|拆出类

+ 指明函数是否会抛异常
    + throw() nothrow
    + noexcept

## 注释(67-88)

+ 注释会随着时间变得无效乃至误导

+ 注释的利与弊
    + 如果编码足够有表达力, 注释根本不需要
    + 注释的恰当用法是弥补我们在用代码表达意图时遭遇的"失败"
    + 尽管有时候也需要注释, 我们也该多花心思尽量减少注释

+ 用代码来阐述
    + 变量名
    + 函数名
    + 类名

+ 好注释
    + 法律版权信息
    + 对意图的解释
    + 阐释
    + 警示
    + TODO注释要做还没有做的内容
    + 公共API中的Javadoc(API没有注释会导致使用的人浪费时间)

+ 坏注释
    + 太多了(每次当你想写注释的时候可以翻看文档查阅)

## 格式(89-104)

+ 代码风格对后来维护人的影响

+ 垂直格式
    + 200 - 500 行原则
    + 文件名 高层次概念 细节
    + 空行
    + 变量延迟声明(用到的时候再声明)
    + 主调在上|被调在下

+ 横向格式
    + 80列 120列
    + 空格
    + 缩进
    + 空范围 换行缩进加括号

+ 团队规则
    + 读者不希望同一个项目里面不同的文件代码风格不一样
    + 代码自动格式化工具(类比自动化测试工具)
    + vim gg == 10== v=

+ 鲍勃大叔的格式规则

## 对象和数据结构(90-112)
+ 数据抽象
    + 尽量避免存取函数, 会暴漏私有成员变量

+ 数据、对象的反对称性
    + 针对同一类型的对象或接口处理时的问题
    + 过程式代码难以添加新数据结构, 必须修改所有函数(分支,开闭原则)
    + 面向对象代码难以添加新函数, 必须修改所有类(多态,开闭原则)

+ 得墨忒耳律 类C的方法f只应该调用以下对象的方法
    + C
    + 由f创建的对象
    + 作为参数传给f的对象
    + 由C的实体变量所持有的对象
        
        final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();

+ 数据传送对象
    + 纯数据DTO
    + 数据+操作

## 错误处理(113-122)

+ 当错误发生时，程序员有责任确保代码照常工作
    + 错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法

+ 使用异常而非返回码
    + 关乎美感

+ 先写try-catch-finally

+ 使用不可控异常
    
+ 给出异常发生的环境说明
    + 打日志

+ 依调用者需要定义异常类
    + 打包类

+ 定义常规流程
    + 特例对象

+ 别返回null值
    + 抛异常或者返回特例对象

+ 别传递null值

## 边界(123-128)

+ 使用第三方代码
    + 适配器模式
    + 封装map
    + 对于第三方代码使用的部分要进行测试

+ 学习性测试
    + 测试脚本

+ 使用尚不存在的代码
    + 适配器模式封装本地API

## 单元测试(129-140)

+ 测试驱动开发

+ 自动化单元测试

+ TDD三定律
    + 在编写不能通过的单元测试前，不可编写生产代码
    + 只可编写刚好无法通过的单元测试，不能编译也算不通过
    + 只可编写刚好足以通过所有失败测试的生产代码

+ 保持测试整洁 
    + 测试代码和生产代码一样重要

+ 整洁测试
    + 可读性|简结且具有表达力
    + 构造测试数据|操作测试数据|检验操作结果
    + 一种测试语言

+ 每个测试一个断言
    + 单个测试中的断言数量应该最小化
    + 每个测试只测一个概念

+ First
    + 快速
    + 独立
    + 可重复
    + 自足验证
    + 及时

## 类(141-156)

+ 类的组织
    + 封装(放松封装就是下策)
    + 公有静态|私有静态|私有变量
    + 公有函数私有函数(紧随)
    + 自顶向下(看报纸)

+ 类应该短小
    + 如果无法为某个类命以精确的名称，这个类大概就长了，类名不超过25字符
    + 单一职责原则(类或模块应该只有一条嫁衣修改的理由)
    + 高内聚低耦合

+ 为了修改而组织
    + 开放-闭合原则
    + 依赖导致原则

## 系统(157-172)

+ 如何构造一个城市
    + 软件系统应将启动过程和启动过程之后的运行时逻辑分离开

+ 将系统的构造与使用分开
    + 构造过程搬迁到main或称之为main的模块中(not null)
    + 工厂(接口和实现分离)(隐藏构造细节)
    + 依赖注入 依赖查找 控制反转(引用传递代替实现new)
    + 反射机制

+ 扩容
    + 吞吐量|可用性|扩展性|一致性
    + 迭代 增量敏捷
    + 切分重构
    + TDD测试驱动开发:先编写测试|功能&测试|重构&测试

+ 测试驱动系统架构

+ 优化决策
    + 最好授权给最优资格的人
    + 延迟决策(越靠后获取的信息越多，更能精准的进行决策)

+ 使用添加了可论证价值的标准
    + 使用经过实战的组件

+ DSL领域特定语言

+ 无论是设计系统或单独的模块，简单最好

## 跌进(173-)

